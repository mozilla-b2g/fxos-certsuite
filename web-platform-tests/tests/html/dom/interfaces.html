<!doctype html>
<meta charset=utf-8>
<!-- WARNING: These tests are preliminary and probably partly incorrect.  -->
<title>HTML IDL tests</title>
<script src=/resources/testharness.js></script>
<script src=/resources/testharnessreport.js></script>
<script src=/resources/WebIDLParser.js></script>
<script src=/resources/idlharness.js></script>

<h1>HTML IDL tests</h1>
<div id=log></div>

<!-- URL IDLs -->
<script type=text/plain class=untested>
[Constructor(DOMString url, optional (URL or DOMString) base = "about:blank")]
interface URL {
};
URL implements URLUtils;

[NoInterfaceObject]
interface URLUtils {
  stringifier attribute DOMString href;
  readonly attribute DOMString origin;

           attribute DOMString protocol;
           attribute DOMString username;
           attribute DOMString password;
           attribute DOMString host;
           attribute DOMString hostname;
           attribute DOMString port;
           attribute DOMString pathname;
           attribute DOMString search;
           attribute URLQuery? query;
           attribute DOMString hash;
};

[NoInterfaceObject]
interface URLUtilsReadOnly {
  stringifier readonly attribute DOMString href;

  readonly attribute DOMString protocol;
  readonly attribute DOMString host;
  readonly attribute DOMString hostname;
  readonly attribute DOMString port;
  readonly attribute DOMString pathname;
  readonly attribute DOMString search;
  readonly attribute DOMString hash;
};
</script>
<!-- DOM IDLs -->
<script type=text/plain class=untested>
exception DOMException {
  const unsigned short INDEX_SIZE_ERR = 1;
  const unsigned short DOMSTRING_SIZE_ERR = 2; // historical
  const unsigned short HIERARCHY_REQUEST_ERR = 3;
  const unsigned short WRONG_DOCUMENT_ERR = 4;
  const unsigned short INVALID_CHARACTER_ERR = 5;
  const unsigned short NO_DATA_ALLOWED_ERR = 6; // historical
  const unsigned short NO_MODIFICATION_ALLOWED_ERR = 7;
  const unsigned short NOT_FOUND_ERR = 8;
  const unsigned short NOT_SUPPORTED_ERR = 9;
  const unsigned short INUSE_ATTRIBUTE_ERR = 10; // historical
  const unsigned short INVALID_STATE_ERR = 11;
  const unsigned short SYNTAX_ERR = 12;
  const unsigned short INVALID_MODIFICATION_ERR = 13;
  const unsigned short NAMESPACE_ERR = 14;
  const unsigned short INVALID_ACCESS_ERR = 15;
  const unsigned short VALIDATION_ERR = 16; // historical
  const unsigned short TYPE_MISMATCH_ERR = 17; // historical; use TypeError instead
  const unsigned short SECURITY_ERR = 18;
  const unsigned short NETWORK_ERR = 19;
  const unsigned short ABORT_ERR = 20;
  const unsigned short URL_MISMATCH_ERR = 21;
  const unsigned short QUOTA_EXCEEDED_ERR = 22;
  const unsigned short TIMEOUT_ERR = 23;
  const unsigned short INVALID_NODE_TYPE_ERR = 24;
  const unsigned short DATA_CLONE_ERR = 25;
  unsigned short code;
};

[Constructor(DOMString name)]
interface DOMError {
  readonly attribute DOMString name;
};

[Constructor(DOMString type, optional EventInit eventInitDict)]
interface Event {
  readonly attribute DOMString type;
  readonly attribute EventTarget? target;
  readonly attribute EventTarget? currentTarget;

  const unsigned short NONE = 0;
  const unsigned short CAPTURING_PHASE = 1;
  const unsigned short AT_TARGET = 2;
  const unsigned short BUBBLING_PHASE = 3;
  readonly attribute unsigned short eventPhase;

  void stopPropagation();
  void stopImmediatePropagation();

  readonly attribute boolean bubbles;
  readonly attribute boolean cancelable;
  void preventDefault();
  readonly attribute boolean defaultPrevented;

  [Unforgeable] readonly attribute boolean isTrusted;
  readonly attribute DOMTimeStamp timeStamp;

  void initEvent(DOMString type, boolean bubbles, boolean cancelable);
};

dictionary EventInit {
  boolean bubbles = false;
  boolean cancelable = false;
};

[Constructor(DOMString type, optional CustomEventInit eventInitDict)]
interface CustomEvent : Event {
  readonly attribute any detail;

  void initCustomEvent(DOMString type, boolean bubbles, boolean cancelable, any details);
};

dictionary CustomEventInit : EventInit {
  any detail = null;
};

interface EventTarget {
  void addEventListener(DOMString type, EventListener? callback, optional boolean capture);
  void removeEventListener(DOMString type, EventListener? callback, optional boolean capture);
  boolean dispatchEvent(Event event);
};

[Callback]
interface EventListener {
  void handleEvent(Event event);
};

[NoInterfaceObject]
interface ParentNode {
  readonly attribute HTMLCollection children;
  readonly attribute Element? firstElementChild;
  readonly attribute Element? lastElementChild;
  readonly attribute unsigned long childElementCount;

  void prepend((Node or DOMString)... nodes);
  void append((Node or DOMString)... nodes);
};
Document implements ParentNode;
DocumentFragment implements ParentNode;
Element implements ParentNode;

[NoInterfaceObject]
interface ChildNode {
  readonly attribute Element? previousElementSibling;
  readonly attribute Element? nextElementSibling;

  void before((Node or DOMString)... nodes);
  void after((Node or DOMString)... nodes);
  void replace((Node or DOMString)... nodes);
  void remove();
};
DocumentType implements ChildNode;
Element implements ChildNode;
CharacterData implements ChildNode;

[Constructor(MutationCallback callback)]
interface MutationObserver {
  void observe(Node target, MutationObserverInit options);
  void disconnect();
  sequence<MutationRecord> takeRecords();
};

callback MutationCallback = void (sequence<MutationRecord> mutations, MutationObserver observer);

dictionary MutationObserverInit {
  boolean childList = false;
  boolean attributes = false;
  boolean characterData = false;
  boolean subtree = false;
  boolean attributeOldValue = false;
  boolean characterDataOldValue = false;
  sequence<DOMString> attributeFilter;
};

interface MutationRecord {
  readonly attribute DOMString type;
  readonly attribute Node target;
  readonly attribute NodeList addedNodes;
  readonly attribute NodeList removedNodes;
  readonly attribute Node? previousSibling;
  readonly attribute Node? nextSibling;
  readonly attribute DOMString? attributeName;
  readonly attribute DOMString? attributeNamespace;
  readonly attribute DOMString? oldValue;
};

interface Node : EventTarget {
  const unsigned short ELEMENT_NODE = 1;
  const unsigned short ATTRIBUTE_NODE = 2; // historical
  const unsigned short TEXT_NODE = 3;
  const unsigned short CDATA_SECTION_NODE = 4; // historical
  const unsigned short ENTITY_REFERENCE_NODE = 5; // historical
  const unsigned short ENTITY_NODE = 6; // historical
  const unsigned short PROCESSING_INSTRUCTION_NODE = 7;
  const unsigned short COMMENT_NODE = 8;
  const unsigned short DOCUMENT_NODE = 9;
  const unsigned short DOCUMENT_TYPE_NODE = 10;
  const unsigned short DOCUMENT_FRAGMENT_NODE = 11;
  const unsigned short NOTATION_NODE = 12; // historical
  readonly attribute unsigned short nodeType;
  readonly attribute DOMString nodeName;

  readonly attribute DOMString? baseURI;

  readonly attribute Document? ownerDocument;
  readonly attribute Node? parentNode;
  readonly attribute Element? parentElement;
  boolean hasChildNodes();
  readonly attribute NodeList childNodes;
  readonly attribute Node? firstChild;
  readonly attribute Node? lastChild;
  readonly attribute Node? previousSibling;
  readonly attribute Node? nextSibling;

           attribute DOMString? nodeValue;
           attribute DOMString? textContent;
  void normalize();

  Node cloneNode(optional boolean deep);
  boolean isEqualNode(Node? node);

  const unsigned short DOCUMENT_POSITION_DISCONNECTED = 0x01;
  const unsigned short DOCUMENT_POSITION_PRECEDING = 0x02;
  const unsigned short DOCUMENT_POSITION_FOLLOWING = 0x04;
  const unsigned short DOCUMENT_POSITION_CONTAINS = 0x08;
  const unsigned short DOCUMENT_POSITION_CONTAINED_BY = 0x10;
  const unsigned short DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;
  unsigned short compareDocumentPosition(Node other);
  boolean contains(Node? other);

  DOMString? lookupPrefix(DOMString? namespace);
  DOMString? lookupNamespaceURI(DOMString? prefix);
  boolean isDefaultNamespace(DOMString? namespace);

  Node insertBefore(Node node, Node? child);
  Node appendChild(Node node);
  Node replaceChild(Node node, Node child);
  Node removeChild(Node child);
};

[Constructor]
interface Document : Node {
  readonly attribute DOMImplementation implementation;
  readonly attribute DOMString URL;
  readonly attribute DOMString documentURI;
  readonly attribute DOMString compatMode;
  readonly attribute DOMString characterSet;
  readonly attribute DOMString contentType;

  readonly attribute DocumentType? doctype;
  readonly attribute Element? documentElement;
  HTMLCollection getElementsByTagName(DOMString localName);
  HTMLCollection getElementsByTagNameNS(DOMString? namespace, DOMString localName);
  HTMLCollection getElementsByClassName(DOMString classNames);
  Element? getElementById(DOMString elementId);

  Element createElement(DOMString localName);
  Element createElementNS(DOMString? namespace, DOMString qualifiedName);
  DocumentFragment createDocumentFragment();
  Text createTextNode(DOMString data);
  Comment createComment(DOMString data);
  ProcessingInstruction createProcessingInstruction(DOMString target, DOMString data);

  Node importNode(Node node, optional boolean deep);
  Node adoptNode(Node node);

  Event createEvent(DOMString interface);

  Range createRange();

  // NodeFilter.SHOW_ALL = 0xFFFFFFFF
  NodeIterator createNodeIterator(Node root, optional unsigned long whatToShow, optional NodeFilter? filter);
  TreeWalker createTreeWalker(Node root, optional unsigned long whatToShow, optional NodeFilter? filter);
};

interface XMLDocument : Document {};

interface DOMImplementation {
  DocumentType createDocumentType(DOMString qualifiedName, DOMString publicId, DOMString systemId);
  XMLDocument createDocument(DOMString? namespace, [TreatNullAs=EmptyString] DOMString qualifiedName, DocumentType? doctype);
  Document createHTMLDocument(optional DOMString title);

  boolean hasFeature(DOMString feature, [TreatNullAs=EmptyString] DOMString version);
};

[Constructor]
interface DocumentFragment : Node {
};

interface DocumentType : Node {
  readonly attribute DOMString name;
  readonly attribute DOMString publicId;
  readonly attribute DOMString systemId;
};

interface Element : Node {
  readonly attribute DOMString? namespaceURI;
  readonly attribute DOMString? prefix;
  readonly attribute DOMString localName;
  readonly attribute DOMString tagName;

           attribute DOMString id;
           attribute DOMString className;
  readonly attribute DOMTokenList classList;

  readonly attribute Attr[] attributes;
  DOMString? getAttribute(DOMString name);
  DOMString? getAttributeNS(DOMString? namespace, DOMString localName);
  void setAttribute(DOMString name, DOMString value);
  void setAttributeNS(DOMString? namespace, DOMString name, DOMString value);
  void removeAttribute(DOMString name);
  void removeAttributeNS(DOMString? namespace, DOMString localName);
  boolean hasAttribute(DOMString name);
  boolean hasAttributeNS(DOMString? namespace, DOMString localName);

  HTMLCollection getElementsByTagName(DOMString localName);
  HTMLCollection getElementsByTagNameNS(DOMString? namespace, DOMString localName);
  HTMLCollection getElementsByClassName(DOMString classNames);
};

interface Attr {
  readonly attribute DOMString localName;
           attribute DOMString value;

  readonly attribute DOMString name;
  readonly attribute DOMString? namespaceURI;
  readonly attribute DOMString? prefix;
};

interface CharacterData : Node {
  [TreatNullAs=EmptyString] attribute DOMString data;
  readonly attribute unsigned long length;
  DOMString substringData(unsigned long offset, unsigned long count);
  void appendData(DOMString data);
  void insertData(unsigned long offset, DOMString data);
  void deleteData(unsigned long offset, unsigned long count);
  void replaceData(unsigned long offset, unsigned long count, DOMString data);
};

[Constructor(optional DOMString data)]
interface Text : CharacterData {
  Text splitText(unsigned long offset);
  readonly attribute DOMString wholeText;
};

interface ProcessingInstruction : CharacterData {
  readonly attribute DOMString target;
};

[Constructor(optional DOMString data)]
interface Comment : CharacterData {
};

[Constructor]
interface Range {
  readonly attribute Node startContainer;
  readonly attribute unsigned long startOffset;
  readonly attribute Node endContainer;
  readonly attribute unsigned long endOffset;
  readonly attribute boolean collapsed;
  readonly attribute Node commonAncestorContainer;

  void setStart(Node refNode, unsigned long offset);
  void setEnd(Node refNode, unsigned long offset);
  void setStartBefore(Node refNode);
  void setStartAfter(Node refNode);
  void setEndBefore(Node refNode);
  void setEndAfter(Node refNode);
  void collapse(boolean toStart);
  void selectNode(Node refNode);
  void selectNodeContents(Node refNode);

  const unsigned short START_TO_START = 0;
  const unsigned short START_TO_END = 1;
  const unsigned short END_TO_END = 2;
  const unsigned short END_TO_START = 3;
  short compareBoundaryPoints(unsigned short how, Range sourceRange);

  void deleteContents();
  DocumentFragment extractContents();
  DocumentFragment cloneContents();
  void insertNode(Node node);
  void surroundContents(Node newParent);

  Range cloneRange();
  void detach();

  boolean isPointInRange(Node node, unsigned long offset);
  short comparePoint(Node node, unsigned long offset);

  boolean intersectsNode(Node node);

  stringifier;
};

interface NodeIterator {
  readonly attribute Node root;
  readonly attribute Node? referenceNode;
  readonly attribute boolean pointerBeforeReferenceNode;
  readonly attribute unsigned long whatToShow;
  readonly attribute NodeFilter? filter;

  Node? nextNode();
  Node? previousNode();

  void detach();
};

interface TreeWalker {
  readonly attribute Node root;
  readonly attribute unsigned long whatToShow;
  readonly attribute NodeFilter? filter;
           attribute Node currentNode;

  Node? parentNode();
  Node? firstChild();
  Node? lastChild();
  Node? previousSibling();
  Node? nextSibling();
  Node? previousNode();
  Node? nextNode();
};

[Callback]
interface NodeFilter {
  // Constants for acceptNode()
  const unsigned short FILTER_ACCEPT = 1;
  const unsigned short FILTER_REJECT = 2;
  const unsigned short FILTER_SKIP = 3;

  // Constants for whatToShow
  const unsigned long SHOW_ALL = 0xFFFFFFFF;
  const unsigned long SHOW_ELEMENT = 0x1;
  const unsigned long SHOW_ATTRIBUTE = 0x2; // historical
  const unsigned long SHOW_TEXT = 0x4;
  const unsigned long SHOW_CDATA_SECTION = 0x8; // historical
  const unsigned long SHOW_ENTITY_REFERENCE = 0x10; // historical
  const unsigned long SHOW_ENTITY = 0x20; // historical
  const unsigned long SHOW_PROCESSING_INSTRUCTION = 0x40;
  const unsigned long SHOW_COMMENT = 0x80;
  const unsigned long SHOW_DOCUMENT = 0x100;
  const unsigned long SHOW_DOCUMENT_TYPE = 0x200;
  const unsigned long SHOW_DOCUMENT_FRAGMENT = 0x400;
  const unsigned long SHOW_NOTATION = 0x800; // historical

  unsigned short acceptNode(Node node);
};

[ArrayClass]
interface NodeList {
  getter Node? item(unsigned long index);
  readonly attribute unsigned long length;
};

interface HTMLCollection {
  readonly attribute unsigned long length;
  getter Element? item(unsigned long index);
  getter object? namedItem(DOMString name); // only returns Element
};

interface DOMTokenList {
  readonly attribute unsigned long length;
  getter DOMString? item(unsigned long index);
  boolean contains(DOMString token);
  void add(DOMString... tokens);
  void remove(DOMString... tokens);
  boolean toggle(DOMString token, optional boolean force);
  stringifier;
};

interface DOMSettableTokenList : DOMTokenList {
            attribute DOMString value;
};
</script>
<!-- CSSOM IDLs -->
<script type=text/plain class=untested>
interface MediaList {
  stringifier attribute DOMString mediaText;
  readonly attribute unsigned long length;
  getter DOMString item(unsigned long index);
  void appendMedium(DOMString medium);
  void deleteMedium(DOMString medium);
};

interface StyleSheet {
  readonly attribute DOMString type;
  readonly attribute DOMString href;
  readonly attribute Node ownerNode;
  readonly attribute StyleSheet parentStyleSheet;
  readonly attribute DOMString title;
  [PutForwards=mediaText] readonly attribute MediaList media;
           attribute boolean disabled;
};

interface CSSStyleSheet : StyleSheet {
  readonly attribute CSSRule ownerRule;
  readonly attribute CSSRuleList cssRules;
  unsigned long insertRule(DOMString rule, unsigned long index);
  void deleteRule(unsigned long index);
};

typedef sequence<StyleSheet> StyleSheetList;

partial interface Document {
  readonly attribute StyleSheetList styleSheets;
           attribute DOMString? selectedStyleSheetSet;
  readonly attribute DOMString? lastStyleSheetSet;
  readonly attribute DOMString? preferredStyleSheetSet;
  readonly attribute DOMStringList styleSheetSets;
  void enableStyleSheetsForSet(DOMString? name);
};

[NoInterfaceObject] interface LinkStyle {
  readonly attribute StyleSheet sheet;
};

ProcessingInstruction implements LinkStyle;

typedef sequence<CSSRule> CSSRuleList;

interface CSSRule {
  // Types
  const unsigned short STYLE_RULE = 1;
  const unsigned short IMPORT_RULE = 3;
  const unsigned short MEDIA_RULE = 4;
  const unsigned short FONT_FACE_RULE = 5;
  const unsigned short PAGE_RULE = 6;
  const unsigned short NAMESPACE_RULE = 10;
  readonly attribute unsigned short type;

  // Parsing and serialization
           attribute DOMString cssText;

  // Context
  readonly attribute CSSRule parentRule;
  readonly attribute CSSStyleSheet parentStyleSheet;
};

interface CSSStyleRule : CSSRule {
           attribute DOMString selectorText;
  readonly attribute CSSStyleDeclaration style;
};

interface CSSImportRule : CSSRule {
  readonly attribute DOMString href;
  [PutForwards=mediaText] readonly attribute MediaList media;
  readonly attribute CSSStyleSheet styleSheet;
};

interface CSSMediaRule : CSSRule {
  [PutForwards=mediaText] readonly attribute MediaList media;
  readonly attribute CSSRuleList cssRules;
  unsigned long insertRule(DOMString rule, unsigned long index);
  void deleteRule(unsigned long index);
};

interface CSSFontFaceRule : CSSRule {
  readonly attribute CSSStyleDeclaration style;
};

interface CSSPageRule : CSSRule {
           attribute DOMString selectorText;
  readonly attribute CSSStyleDeclaration style;
};

interface CSSNamespaceRule : CSSRule {
  readonly attribute DOMString namespaceURI;
  readonly attribute DOMString? prefix;
};

interface CSSStyleDeclaration {
           attribute DOMString cssText;

  readonly attribute unsigned long length;
  DOMString item(unsigned long index);

  DOMString getPropertyValue(DOMString property);
  DOMString getPropertyPriority(DOMString property);
  void setProperty(DOMString property, DOMString value, optional DOMString priority);
  DOMString removeProperty(DOMString property);

  readonly attribute CSSStyleDeclarationValue values;

  readonly attribute CSSRule parentRule;

  // CSS Properties
           attribute DOMString azimuth;
           attribute DOMString background;
           attribute DOMString backgroundAttachment;
           attribute DOMString backgroundColor;
           attribute DOMString backgroundImage;
           attribute DOMString backgroundPosition;
           attribute DOMString backgroundRepeat;
           attribute DOMString border;
           attribute DOMString borderCollapse;
           attribute DOMString borderColor;
           attribute DOMString borderSpacing;
           attribute DOMString borderStyle;
           attribute DOMString borderTop;
           attribute DOMString borderRight;
           attribute DOMString borderBottom;
           attribute DOMString borderLeft;
           attribute DOMString borderTopColor;
           attribute DOMString borderRightColor;
           attribute DOMString borderBottomColor;
           attribute DOMString borderLeftColor;
           attribute DOMString borderTopStyle;
           attribute DOMString borderRightStyle;
           attribute DOMString borderBottomStyle;
           attribute DOMString borderLeftStyle;
           attribute DOMString borderTopWidth;
           attribute DOMString borderRightWidth;
           attribute DOMString borderBottomWidth;
           attribute DOMString borderLeftWidth;
           attribute DOMString borderWidth;
           attribute DOMString bottom;
           attribute DOMString captionSide;
           attribute DOMString clear;
           attribute DOMString clip;
           attribute DOMString color;
           attribute DOMString content;
           attribute DOMString counterIncrement;
           attribute DOMString counterReset;
           attribute DOMString cue;
           attribute DOMString cueAfter;
           attribute DOMString cueBefore;
           attribute DOMString cursor;
           attribute DOMString direction;
           attribute DOMString display;
           attribute DOMString elevation;
           attribute DOMString emptyCells;
           attribute DOMString cssFloat;
           attribute DOMString font;
           attribute DOMString fontFamily;
           attribute DOMString fontSize;
           attribute DOMString fontSizeAdjust;
           attribute DOMString fontStretch;
           attribute DOMString fontStyle;
           attribute DOMString fontVariant;
           attribute DOMString fontWeight;
           attribute DOMString height;
           attribute DOMString left;
           attribute DOMString letterSpacing;
           attribute DOMString lineHeight;
           attribute DOMString listStyle;
           attribute DOMString listStyleImage;
           attribute DOMString listStylePosition;
           attribute DOMString listStyleType;
           attribute DOMString margin;
           attribute DOMString marginTop;
           attribute DOMString marginRight;
           attribute DOMString marginBottom;
           attribute DOMString marginLeft;
           attribute DOMString markerOffset;
           attribute DOMString marks;
           attribute DOMString maxHeight;
           attribute DOMString maxWidth;
           attribute DOMString minHeight;
           attribute DOMString minWidth;
           attribute DOMString orphans;
           attribute DOMString outline;
           attribute DOMString outlineColor;
           attribute DOMString outlineStyle;
           attribute DOMString outlineWidth;
           attribute DOMString overflow;
           attribute DOMString padding;
           attribute DOMString paddingTop;
           attribute DOMString paddingRight;
           attribute DOMString paddingBottom;
           attribute DOMString paddingLeft;
           attribute DOMString page;
           attribute DOMString pageBreakAfter;
           attribute DOMString pageBreakBefore;
           attribute DOMString pageBreakInside;
           attribute DOMString pause;
           attribute DOMString pauseAfter;
           attribute DOMString pauseBefore;
           attribute DOMString pitch;
           attribute DOMString pitchRange;
           attribute DOMString playDuring;
           attribute DOMString position;
           attribute DOMString quotes;
           attribute DOMString richness;
           attribute DOMString right;
           attribute DOMString size;
           attribute DOMString speak;
           attribute DOMString speakHeader;
           attribute DOMString speakNumeral;
           attribute DOMString speakPunctuation;
           attribute DOMString speechRate;
           attribute DOMString stress;
           attribute DOMString tableLayout;
           attribute DOMString textAlign;
           attribute DOMString textDecoration;
           attribute DOMString textIndent;
           attribute DOMString textShadow;
           attribute DOMString textTransform;
           attribute DOMString top;
           attribute DOMString unicodeBidi;
           attribute DOMString verticalAlign;
           attribute DOMString visibility;
           attribute DOMString voiceFamily;
           attribute DOMString volume;
           attribute DOMString whiteSpace;
           attribute DOMString widows;
           attribute DOMString width;
           attribute DOMString wordSpacing;
           attribute DOMString zIndex;
};

interface CSSStyleDeclarationValue {
  // ...

  // CSS Properties

};

interface CSSPropertyValue {
           attribute DOMString cssText;
};

[NoInterfaceObject] interface CSSMapValue {
  getter CSSValue (DOMString name);
};

[NoInterfaceObject] interface CSSPropertyValueList {
  readonly attribute CSSValue[] list;
};

[NoInterfaceObject] interface CSSComponentValue {
  readonly attribute DOMString type;
           attribute any value;
};

[NoInterfaceObject] interface CSSStringComponentValue {
           attribute DOMString string;
};

[NoInterfaceObject] interface CSSKeywordComponentValue {
           attribute DOMString keyword;
};

[NoInterfaceObject] interface CSSIdentifierComponentValue {
           attribute DOMString identifier;
};

[NoInterfaceObject] interface CSSColorComponentValue {
           attribute short red;
           attribute short green;
           attribute short blue;
           attribute float alpha;
};

[NoInterfaceObject] interface CSSLengthComponentValue {
           attribute float em;
           attribute float ex;
           attribute float px;
           // figure out what to do with absolute lengths
};

[NoInterfaceObject] interface CSSPercentageComponentValue {
           attribute float percent;
};

[NoInterfaceObject] interface CSSURLComponentValue {
           attribute DOMString? url;
};

[NoInterfaceObject] interface ElementCSSInlineStyle {
  readonly attribute CSSStyleDeclaration style;
};

partial interface Window {
  CSSStyleDeclaration getComputedStyle(Element elt);
  CSSStyleDeclaration getComputedStyle(Element elt, DOMString pseudoElt);
};
</script>

<!-- HTML IDLs -->
<script type=text/plain>
interface HTMLAllCollection : HTMLCollection {
  // inherits length and item(unsigned long index)
  object? item(DOMString name);
  legacycaller getter object? namedItem(DOMString name); // shadows inherited namedItem()
  HTMLAllCollection tags(DOMString tagName);
};

interface HTMLFormControlsCollection : HTMLCollection {
  // inherits length and item()
  legacycaller getter object? namedItem(DOMString name); // shadows inherited namedItem()
};

interface RadioNodeList : NodeList {
          attribute DOMString value;
};

interface HTMLOptionsCollection : HTMLCollection {
  // inherits item()
           attribute unsigned long length; // shadows inherited length
  legacycaller getter object? namedItem(DOMString name); // shadows inherited namedItem()
  setter creator void (unsigned long index, HTMLOptionElement? option);
  void add((HTMLOptionElement or HTMLOptGroupElement) element, optional (HTMLElement or long)? before = null);
  void remove(long index);
           attribute long selectedIndex;
};

interface HTMLPropertiesCollection : HTMLCollection {
  // inherits length and item()
  getter PropertyNodeList? namedItem(DOMString name); // shadows inherited namedItem()
  readonly attribute DOMString[] names;
};

typedef sequence<any> PropertyValueArray;

interface PropertyNodeList : NodeList {
  PropertyValueArray getValues();
};

interface DOMStringMap {
  getter DOMString (DOMString name);
  setter creator void (DOMString name, DOMString value);
  deleter void (DOMString name);
};

interface DOMElementMap {
  getter Element (DOMString name);
  setter creator void (DOMString name, Element value);
  deleter void (DOMString name);
};

[NoInterfaceObject]
interface Transferable { };

enum DocumentReadyState { "loading", "interactive", "complete" };

[OverrideBuiltins]
partial /*sealed*/ interface Document {
  // resource metadata management
  [PutForwards=href, Unforgeable] readonly attribute Location? location;
           attribute DOMString domain;
  readonly attribute DOMString referrer;
           attribute DOMString cookie;
  readonly attribute DOMString lastModified;
  readonly attribute DocumentReadyState readyState;

  // DOM tree accessors
  getter object (DOMString name);
           attribute DOMString title;
           attribute DOMString dir;
           attribute HTMLElement? body;
  readonly attribute HTMLHeadElement? head;
  readonly attribute HTMLCollection images;
  readonly attribute HTMLCollection embeds;
  readonly attribute HTMLCollection plugins;
  readonly attribute HTMLCollection links;
  readonly attribute HTMLCollection forms;
  readonly attribute HTMLCollection scripts;
  NodeList getElementsByName(DOMString elementName);
  NodeList getItems(optional DOMString typeNames = ""); // microdata
  readonly attribute DOMElementMap cssElementMap;
  readonly attribute HTMLScriptElement? currentScript;

  // dynamic markup insertion
  Document open(optional DOMString type, optional DOMString replace);
  WindowProxy open(DOMString url, DOMString name, DOMString features, optional boolean replace);
  void close();
  void write(DOMString... text);
  void writeln(DOMString... text);

  // user interaction
  readonly attribute WindowProxy? defaultView;
  readonly attribute Element? activeElement;
  boolean hasFocus();
           attribute DOMString designMode;
  boolean execCommand(DOMString commandId, optional boolean showUI = false, optional DOMString value = "");
  boolean queryCommandEnabled(DOMString commandId);
  boolean queryCommandIndeterm(DOMString commandId);
  boolean queryCommandState(DOMString commandId);
  boolean queryCommandSupported(DOMString commandId);
  DOMString queryCommandValue(DOMString commandId);
  readonly attribute HTMLCollection commands;

  // special event handler IDL attributes that only apply to Document objects
  [LenientThis] attribute EventHandler onreadystatechange;

  // also has obsolete members
};
Document implements GlobalEventHandlers;

partial interface XMLDocument {
  boolean load(DOMString url);
};

interface HTMLElement : Element {
  // metadata attributes
           attribute DOMString title;
           attribute DOMString lang;
           attribute boolean translate;
           attribute DOMString dir;
  readonly attribute DOMStringMap dataset;

  // microdata
           attribute boolean itemScope;
  [PutForwards=value] readonly attribute DOMSettableTokenList itemType;
           attribute DOMString itemId;
  [PutForwards=value] readonly attribute DOMSettableTokenList itemRef;
  [PutForwards=value] readonly attribute DOMSettableTokenList itemProp;
  readonly attribute HTMLPropertiesCollection properties;
           attribute any itemValue; // acts as DOMString on setting

  // user interaction
           attribute boolean hidden;
  void click();
           attribute long tabIndex;
  void focus();
  void blur();
           attribute DOMString accessKey;
  readonly attribute DOMString accessKeyLabel;
           attribute boolean draggable;
  [PutForwards=value] readonly attribute DOMSettableTokenList dropzone;
           attribute DOMString contentEditable;
  readonly attribute boolean isContentEditable;
           attribute HTMLMenuElement? contextMenu;
           attribute boolean spellcheck;
  void forceSpellCheck();

  // command API
  readonly attribute DOMString? commandType;
  readonly attribute DOMString? commandLabel;
  readonly attribute DOMString? commandIcon;
  readonly attribute boolean? commandHidden;
  readonly attribute boolean? commandDisabled;
  readonly attribute boolean? commandChecked;

  // styling
  [PutForwards=cssText] readonly attribute CSSStyleDeclaration style;
};
HTMLElement implements GlobalEventHandlers;

interface HTMLUnknownElement : HTMLElement { };

interface HTMLHtmlElement : HTMLElement {
  // also has obsolete members
};

interface HTMLHeadElement : HTMLElement {};

interface HTMLTitleElement : HTMLElement {
           attribute DOMString text;
};

interface HTMLBaseElement : HTMLElement {
           attribute DOMString href;
           attribute DOMString target;
};

interface HTMLLinkElement : HTMLElement {
           attribute boolean disabled;
           attribute DOMString href;
           attribute DOMString crossOrigin;
           attribute DOMString rel;
  readonly attribute DOMTokenList relList;
           attribute DOMString media;
           attribute DOMString hreflang;
           attribute DOMString type;
  [PutForwards=value] readonly attribute DOMSettableTokenList sizes;

  // also has obsolete members
};
HTMLLinkElement implements LinkStyle;

interface HTMLMetaElement : HTMLElement {
           attribute DOMString name;
           attribute DOMString httpEquiv;
           attribute DOMString content;

  // also has obsolete members
};

interface HTMLStyleElement : HTMLElement {
           attribute boolean disabled;
           attribute DOMString media;
           attribute DOMString type;
           attribute boolean scoped;
};
HTMLStyleElement implements LinkStyle;

interface HTMLScriptElement : HTMLElement {
           attribute DOMString src;
           attribute DOMString type;
           attribute DOMString charset;
           attribute boolean async;
           attribute boolean defer;
           attribute DOMString crossOrigin;
           attribute DOMString text;

  // also has obsolete members
};

interface HTMLBodyElement : HTMLElement {

  // also has obsolete members
};
HTMLBodyElement implements WindowEventHandlers;

interface HTMLHeadingElement : HTMLElement {
  // also has obsolete members
};

interface HTMLParagraphElement : HTMLElement {
  // also has obsolete members
};

interface HTMLHRElement : HTMLElement {
  // also has obsolete members
};

interface HTMLPreElement : HTMLElement {
  // also has obsolete members
};

interface HTMLQuoteElement : HTMLElement {
           attribute DOMString cite;
};

interface HTMLOListElement : HTMLElement {
           attribute boolean reversed;
           attribute long start;
           attribute DOMString type;

  // also has obsolete members
};

interface HTMLUListElement : HTMLElement {
  // also has obsolete members
};

interface HTMLLIElement : HTMLElement {
           attribute long value;

  // also has obsolete members
};

interface HTMLDListElement : HTMLElement {
  // also has obsolete members
};

interface HTMLDivElement : HTMLElement {
  // also has obsolete members
};

interface HTMLAnchorElement : HTMLElement {
  stringifier attribute DOMString href;
           attribute DOMString target;
           attribute DOMString download;
           attribute DOMString ping;
           attribute DOMString rel;
  readonly attribute DOMTokenList relList;
           attribute DOMString hreflang;
           attribute DOMString type;

           attribute DOMString text;

  // also has obsolete members
};
HTMLAnchorElement implements URLUtils;

interface HTMLDataElement : HTMLElement {
           attribute DOMString value;
};

interface HTMLTimeElement : HTMLElement {
           attribute DOMString dateTime;
};

interface HTMLSpanElement : HTMLElement {};

interface HTMLBRElement : HTMLElement {
  // also has obsolete members
};

interface HTMLModElement : HTMLElement {
           attribute DOMString cite;
           attribute DOMString dateTime;
};

[NamedConstructor=Image(optional unsigned long width, optional unsigned long height)]
interface HTMLImageElement : HTMLElement {
           attribute DOMString alt;
           attribute DOMString src;
           attribute DOMString srcset;
           attribute DOMString crossOrigin;
           attribute DOMString useMap;
           attribute boolean isMap;
           attribute unsigned long width;
           attribute unsigned long height;
  readonly attribute unsigned long naturalWidth;
  readonly attribute unsigned long naturalHeight;
  readonly attribute boolean complete;

  // also has obsolete members
};

interface HTMLIFrameElement : HTMLElement {
           attribute DOMString src;
           attribute DOMString srcdoc;
           attribute DOMString name;
  [PutForwards=value] readonly attribute DOMSettableTokenList sandbox;
           attribute boolean seamless;
           attribute boolean allowFullscreen;
           attribute DOMString width;
           attribute DOMString height;
  readonly attribute Document? contentDocument;
  readonly attribute WindowProxy? contentWindow;

  // also has obsolete members
};

interface HTMLEmbedElement : HTMLElement {
           attribute DOMString src;
           attribute DOMString type;
           attribute DOMString width;
           attribute DOMString height;
  legacycaller any (any... arguments);

  // also has obsolete members
};

interface HTMLObjectElement : HTMLElement {
           attribute DOMString data;
           attribute DOMString type;
           attribute boolean typeMustMatch;
           attribute DOMString name;
           attribute DOMString useMap;
  readonly attribute HTMLFormElement? form;
           attribute DOMString width;
           attribute DOMString height;
  readonly attribute Document? contentDocument;
  readonly attribute WindowProxy? contentWindow;

  readonly attribute boolean willValidate;
  readonly attribute ValidityState validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  legacycaller any (any... arguments);

  // also has obsolete members
};

interface HTMLParamElement : HTMLElement {
           attribute DOMString name;
           attribute DOMString value;

  // also has obsolete members
};

interface HTMLVideoElement : HTMLMediaElement {
           attribute unsigned long width;
           attribute unsigned long height;
  readonly attribute unsigned long videoWidth;
  readonly attribute unsigned long videoHeight;
           attribute DOMString poster;
};

[NamedConstructor=Audio(optional DOMString src)]
interface HTMLAudioElement : HTMLMediaElement {};

interface HTMLSourceElement : HTMLElement {
           attribute DOMString src;
           attribute DOMString type;
           attribute DOMString media;
};

interface HTMLTrackElement : HTMLElement {
           attribute DOMString kind;
           attribute DOMString src;
           attribute DOMString srclang;
           attribute DOMString label;
           attribute boolean default;

  const unsigned short NONE = 0;
  const unsigned short LOADING = 1;
  const unsigned short LOADED = 2;
  const unsigned short ERROR = 3;
  readonly attribute unsigned short readyState;

  readonly attribute TextTrack track;
};

interface HTMLMediaElement : HTMLElement {

  // error state
  readonly attribute MediaError? error;

  // network state
           attribute DOMString src;
  readonly attribute DOMString currentSrc;
           attribute DOMString crossOrigin;
  const unsigned short NETWORK_EMPTY = 0;
  const unsigned short NETWORK_IDLE = 1;
  const unsigned short NETWORK_LOADING = 2;
  const unsigned short NETWORK_NO_SOURCE = 3;
  readonly attribute unsigned short networkState;
           attribute DOMString preload;
  readonly attribute TimeRanges buffered;
  void load();
  DOMString canPlayType(DOMString type);

  // ready state
  const unsigned short HAVE_NOTHING = 0;
  const unsigned short HAVE_METADATA = 1;
  const unsigned short HAVE_CURRENT_DATA = 2;
  const unsigned short HAVE_FUTURE_DATA = 3;
  const unsigned short HAVE_ENOUGH_DATA = 4;
  readonly attribute unsigned short readyState;
  readonly attribute boolean seeking;

  // playback state
           attribute double currentTime;
  void fastSeek(double time);
  readonly attribute unrestricted double duration;
  readonly attribute Date startDate;
  readonly attribute boolean paused;
           attribute double defaultPlaybackRate;
           attribute double playbackRate;
  readonly attribute TimeRanges played;
  readonly attribute TimeRanges seekable;
  readonly attribute boolean ended;
           attribute boolean autoplay;
           attribute boolean loop;
  void play();
  void pause();

  // media controller
           attribute DOMString mediaGroup;
           attribute MediaController? controller;

  // controls
           attribute boolean controls;
           attribute double volume;
           attribute boolean muted;
           attribute boolean defaultMuted;

  // tracks
  readonly attribute AudioTrackList audioTracks;
  readonly attribute VideoTrackList videoTracks;
  readonly attribute TextTrackList textTracks;
  TextTrack addTextTrack(DOMString kind, optional DOMString label, optional DOMString language);
};

interface MediaError {
  const unsigned short MEDIA_ERR_ABORTED = 1;
  const unsigned short MEDIA_ERR_NETWORK = 2;
  const unsigned short MEDIA_ERR_DECODE = 3;
  const unsigned short MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
  readonly attribute unsigned short code;
};

interface AudioTrackList : EventTarget {
  readonly attribute unsigned long length;
  getter AudioTrack (unsigned long index);
  AudioTrack? getTrackById(DOMString id);

           attribute EventHandler onchange;
           attribute EventHandler onaddtrack;
           attribute EventHandler onremovetrack;
};

interface AudioTrack {
  readonly attribute DOMString id;
  readonly attribute DOMString kind;
  readonly attribute DOMString label;
  readonly attribute DOMString language;
           attribute boolean enabled;
};

interface VideoTrackList : EventTarget {
  readonly attribute unsigned long length;
  getter VideoTrack (unsigned long index);
  VideoTrack? getTrackById(DOMString id);
  readonly attribute long selectedIndex;

           attribute EventHandler onchange;
           attribute EventHandler onaddtrack;
           attribute EventHandler onremovetrack;
};

interface VideoTrack {
  readonly attribute DOMString id;
  readonly attribute DOMString kind;
  readonly attribute DOMString label;
  readonly attribute DOMString language;
           attribute boolean selected;
};

enum MediaControllerPlaybackState { "waiting", "playing", "ended" };
[Constructor]
interface MediaController : EventTarget {
  readonly attribute unsigned short readyState; // uses HTMLMediaElement.readyState's values

  readonly attribute TimeRanges buffered;
  readonly attribute TimeRanges seekable;
  readonly attribute unrestricted double duration;
           attribute double currentTime;

  readonly attribute boolean paused;
  readonly attribute MediaControllerPlaybackState playbackState;
  readonly attribute TimeRanges played;
  void pause();
  void unpause();
  void play(); // calls play() on all media elements as well

           attribute double defaultPlaybackRate;
           attribute double playbackRate;

           attribute double volume;
           attribute boolean muted;

           attribute EventHandler onemptied;
           attribute EventHandler onloadedmetadata;
           attribute EventHandler onloadeddata;
           attribute EventHandler oncanplay;
           attribute EventHandler oncanplaythrough;
           attribute EventHandler onplaying;
           attribute EventHandler onended;
           attribute EventHandler onwaiting;

           attribute EventHandler ondurationchange;
           attribute EventHandler ontimeupdate;
           attribute EventHandler onplay;
           attribute EventHandler onpause;
           attribute EventHandler onratechange;
           attribute EventHandler onvolumechange;
};

interface TextTrackList : EventTarget {
  readonly attribute unsigned long length;
  getter TextTrack (unsigned long index);

           attribute EventHandler onaddtrack;
           attribute EventHandler onremovetrack;
};

enum TextTrackMode { "disabled", "hidden", "showing" };
interface TextTrack : EventTarget {
  readonly attribute DOMString kind;
  readonly attribute DOMString label;
  readonly attribute DOMString language;
  readonly attribute DOMString inBandMetadataTrackDispatchType;

           attribute TextTrackMode mode;

  readonly attribute TextTrackCueList? cues;
  readonly attribute TextTrackCueList? activeCues;

  void addCue(TextTrackCue cue);
  void removeCue(TextTrackCue cue);

           attribute EventHandler oncuechange;
};

interface TextTrackCueList {
  readonly attribute unsigned long length;
  getter TextTrackCue (unsigned long index);
  TextTrackCue? getCueById(DOMString id);
};

interface TextTrackCue : EventTarget {
  readonly attribute TextTrack? track;

           attribute DOMString id;
           attribute double startTime;
           attribute double endTime;
           attribute boolean pauseOnExit;

           attribute EventHandler onenter;
           attribute EventHandler onexit;
};

interface TimeRanges {
  readonly attribute unsigned long length;
  double start(unsigned long index);
  double end(unsigned long index);
};

[Constructor(DOMString type, optional TrackEventInit eventInitDict)]
interface TrackEvent : Event {
  readonly attribute object? track;
};

dictionary TrackEventInit : EventInit {
  object? track;
};

typedef (CanvasRenderingContext2D or WebGLRenderingContext) RenderingContext;

interface HTMLCanvasElement : HTMLElement {
           attribute unsigned long width;
           attribute unsigned long height;

  RenderingContext? getContext(DOMString contextId, any... arguments);
  boolean supportsContext(DOMString contextId, any... arguments);

  void setContext(RenderingContext context);
  CanvasProxy transferControlToProxy();

  DOMString toDataURL(optional DOMString type, any... arguments);
  DOMString toDataURLHD(optional DOMString type, any... arguments);
  void toBlob(FileCallback? _callback, optional DOMString type, any... arguments);
  void toBlobHD(FileCallback? _callback, optional DOMString type, any... arguments);
};

interface CanvasProxy {
  void setContext(RenderingContext context);
};
CanvasProxy implements Transferable;

typedef (HTMLImageElement or
         HTMLVideoElement or
         HTMLCanvasElement or
         CanvasRenderingContext2D or
         ImageBitmap) CanvasImageSource;

enum CanvasDrawingStylesFillRules { "nonzero", "evenodd" };

[Constructor(optional unsigned long width, unsigned long height)]
interface CanvasRenderingContext2D {

  // back-reference to the canvas
  readonly attribute HTMLCanvasElement canvas;

  // canvas dimensions
           attribute unsigned long width;
           attribute unsigned long height;

  // for contexts that aren't directly fixed to a specific canvas
  void commit(); // push the image to the output bitmap

  // state
  void save(); // push state on state stack
  void restore(); // pop state stack and restore state

  // transformations (default transform is the identity matrix)
           attribute SVGMatrix currentTransform;
  void scale(unrestricted double x, unrestricted double y);
  void rotate(unrestricted double angle);
  void translate(unrestricted double x, unrestricted double y);
  void transform(unrestricted double a, unrestricted double b, unrestricted double c, unrestricted double d, unrestricted double e, unrestricted double f);
  void setTransform(unrestricted double a, unrestricted double b, unrestricted double c, unrestricted double d, unrestricted double e, unrestricted double f);
  void resetTransform();

  // compositing
           attribute unrestricted double globalAlpha; // (default 1.0)
           attribute DOMString globalCompositeOperation; // (default source-over)

  // image smoothing
           attribute boolean imageSmoothingEnabled; // (default true)

  // colors and styles (see also the CanvasDrawingStyles interface)
           attribute (DOMString or CanvasGradient or CanvasPattern) strokeStyle; // (default black)
           attribute (DOMString or CanvasGradient or CanvasPattern) fillStyle; // (default black)
  CanvasGradient createLinearGradient(double x0, double y0, double x1, double y1);
  CanvasGradient createRadialGradient(double x0, double y0, double r0, double x1, double y1, double r1);
  CanvasPattern createPattern(CanvasImageSource image, DOMString repetition);

  // shadows
           attribute unrestricted double shadowOffsetX; // (default 0)
           attribute unrestricted double shadowOffsetY; // (default 0)
           attribute unrestricted double shadowBlur; // (default 0)
           attribute DOMString shadowColor; // (default transparent black)

  // rects
  void clearRect(unrestricted double x, unrestricted double y, unrestricted double w, unrestricted double h);
  void fillRect(unrestricted double x, unrestricted double y, unrestricted double w, unrestricted double h);
  void strokeRect(unrestricted double x, unrestricted double y, unrestricted double w, unrestricted double h);

  // path API (see also CanvasPathMethods)
           attribute CanvasDrawingStylesFillRules fillRule; // (default "nonzero")
  void beginPath();
  void fill();
  void fill(Path path);
  void stroke();
  void stroke(Path path);
  void drawSystemFocusRing(Element element);
  void drawSystemFocusRing(Path path, Element element);
  boolean drawCustomFocusRing(Element element);
  boolean drawCustomFocusRing(Path path, Element element);
  void scrollPathIntoView();
  void scrollPathIntoView(Path path);
  void clip();
  void clip(Path path);
  void resetClip();
  boolean isPointInPath(unrestricted double x, unrestricted double y);
  boolean isPointInPath(Path path, unrestricted double x, unrestricted double y);

  // text (see also the CanvasDrawingStyles interface)
  void fillText(DOMString text, unrestricted double x, unrestricted double y, optional unrestricted double maxWidth);
  void strokeText(DOMString text, unrestricted double x, unrestricted double y, optional unrestricted double maxWidth);
  TextMetrics measureText(DOMString text);

  // drawing images
  void drawImage(CanvasImageSource image, unrestricted double dx, unrestricted double dy);
  void drawImage(CanvasImageSource image, unrestricted double dx, unrestricted double dy, unrestricted double dw, unrestricted double dh);
  void drawImage(CanvasImageSource image, unrestricted double sx, unrestricted double sy, unrestricted double sw, unrestricted double sh, unrestricted double dx, unrestricted double dy, unrestricted double dw, unrestricted double dh);

  // hit regions
  void addHitRegion(HitRegionOptions options);
  void removeHitRegion(HitRegionOptions options);

  // pixel manipulation
  ImageData createImageData(double sw, double sh);
  ImageData createImageData(ImageData imagedata);
  ImageData createImageDataHD(double sw, double sh);
  ImageData getImageData(double sx, double sy, double sw, double sh);
  ImageData getImageDataHD(double sx, double sy, double sw, double sh);
  void putImageData(ImageData imagedata, double dx, double dy);
  void putImageData(ImageData imagedata, double dx, double dy, double dirtyX, double dirtyY, double dirtyWidth, double dirtyHeight);
  void putImageDataHD(ImageData imagedata, double dx, double dy);
  void putImageDataHD(ImageData imagedata, double dx, double dy, double dirtyX, double dirtyY, double dirtyWidth, double dirtyHeight);
};
CanvasRenderingContext2D implements CanvasDrawingStyles;
CanvasRenderingContext2D implements CanvasPathMethods;

[NoInterfaceObject]
interface CanvasDrawingStyles {
  // line caps/joins
           attribute unrestricted double lineWidth; // (default 1)
           attribute DOMString lineCap; // "butt", "round", "square" (default "butt")
           attribute DOMString lineJoin; // "round", "bevel", "miter" (default "miter")
           attribute unrestricted double miterLimit; // (default 10)

  // dashed lines
  void setLineDash(sequence<unrestricted double> segments); // default empty
  sequence<unrestricted double> getLineDash();
           attribute unrestricted double lineDashOffset;

  // text
           attribute DOMString font; // (default 10px sans-serif)
           attribute DOMString textAlign; // "start", "end", "left", "right", "center" (default: "start")
           attribute DOMString textBaseline; // "top", "hanging", "middle", "alphabetic", "ideographic", "bottom" (default: "alphabetic")
           attribute DOMString direction; // "ltr", "rtl", "inherit" (default: "inherit")
};

[NoInterfaceObject]
interface CanvasPathMethods {
  // shared path API methods
  void closePath();
  void moveTo(unrestricted double x, unrestricted double y);
  void lineTo(unrestricted double x, unrestricted double y);
  void quadraticCurveTo(unrestricted double cpx, unrestricted double cpy, unrestricted double x, unrestricted double y);
  void bezierCurveTo(unrestricted double cp1x, unrestricted double cp1y, unrestricted double cp2x, unrestricted double cp2y, unrestricted double x, unrestricted double y);
  void arcTo(unrestricted double x1, unrestricted double y1, unrestricted double x2, unrestricted double y2, unrestricted double radius);
  void arcTo(unrestricted double x1, unrestricted double y1, unrestricted double x2, unrestricted double y2, unrestricted double radiusX, unrestricted double radiusY, unrestricted double rotation);
  void rect(unrestricted double x, unrestricted double y, unrestricted double w, unrestricted double h);
  void arc(unrestricted double x, unrestricted double y, unrestricted double radius, unrestricted double startAngle, unrestricted double endAngle, optional boolean anticlockwise = false);
  void ellipse(unrestricted double x, unrestricted double y, unrestricted double radiusX, unrestricted double radiusY, unrestricted double rotation, unrestricted double startAngle, unrestricted double endAngle, boolean anticlockwise);
};

interface CanvasGradient {
  // opaque object
  void addColorStop(double offset, DOMString color);
};

interface CanvasPattern {
  // opaque object
  void setTransform(SVGMatrix transform);
};

interface TextMetrics {
  // x-direction
  readonly attribute double width; // advance width
  readonly attribute double actualBoundingBoxLeft;
  readonly attribute double actualBoundingBoxRight;

  // y-direction
  readonly attribute double fontBoundingBoxAscent;
  readonly attribute double fontBoundingBoxDescent;
  readonly attribute double actualBoundingBoxAscent;
  readonly attribute double actualBoundingBoxDescent;
  readonly attribute double emHeightAscent;
  readonly attribute double emHeightDescent;
  readonly attribute double hangingBaseline;
  readonly attribute double alphabeticBaseline;
  readonly attribute double ideographicBaseline;
};

dictionary HitRegionOptions {
  Path? path = null;
  DOMString id = "";
  DOMString? parentID = null;
  DOMString cursor = "inherit";
  // for control-backed regions:
  Element? control = null;
  // for unbacked regions:
  DOMString? label = null;
  DOMString? role = null;
};

interface ImageData {
  readonly attribute unsigned long width;
  readonly attribute unsigned long height;
  readonly attribute Uint8ClampedArray data;
};

[Constructor(optional Element scope)]
interface DrawingStyle { };
DrawingStyle implements CanvasDrawingStyles;

[Constructor,
 Constructor(Path path),
 Constructor(DOMString d)]
interface Path {
  void addPath(Path path, SVGMatrix? transformation);
  void addPathByStrokingPath(Path path, CanvasDrawingStyles styles, SVGMatrix? transformation);
  void addText(DOMString text, CanvasDrawingStyles styles, SVGMatrix? transformation, unrestricted double x, unrestricted double y, optional unrestricted double maxWidth);
  void addPathByStrokingText(DOMString text, CanvasDrawingStyles styles, SVGMatrix? transformation, unrestricted double x, unrestricted double y, optional unrestricted double maxWidth);
  void addText(DOMString text, CanvasDrawingStyles styles, SVGMatrix? transformation, Path path, optional unrestricted double maxWidth);
  void addPathByStrokingText(DOMString text, CanvasDrawingStyles styles, SVGMatrix? transformation, Path path, optional unrestricted double maxWidth);
};
Path implements CanvasPathMethods;

/*partial interface MouseEvent {
  readonly attribute DOMString? region;
};

partial dictionary MouseEventInit {
  DOMString? region;
};*/

interface HTMLMapElement : HTMLElement {
           attribute DOMString name;
  readonly attribute HTMLCollection areas;
  readonly attribute HTMLCollection images;
};

interface HTMLAreaElement : HTMLElement {
           attribute DOMString alt;
           attribute DOMString coords;
           attribute DOMString shape;
  stringifier attribute DOMString href;
           attribute DOMString target;
           attribute DOMString download;
           attribute DOMString ping;
           attribute DOMString rel;
  readonly attribute DOMTokenList relList;
           attribute DOMString hreflang;
           attribute DOMString type;

  // also has obsolete members
};
HTMLAreaElement implements URLUtils;

interface HTMLTableElement : HTMLElement {
           attribute HTMLTableCaptionElement? caption;
  HTMLElement createCaption();
  void deleteCaption();
           attribute HTMLTableSectionElement? tHead;
  HTMLElement createTHead();
  void deleteTHead();
           attribute HTMLTableSectionElement? tFoot;
  HTMLElement createTFoot();
  void deleteTFoot();
  readonly attribute HTMLCollection tBodies;
  HTMLElement createTBody();
  readonly attribute HTMLCollection rows;
  HTMLElement insertRow(optional long index = -1);
  void deleteRow(long index);
           attribute boolean sortable;
  void stopSorting();

  // also has obsolete members
};

interface HTMLTableCaptionElement : HTMLElement {
  // also has obsolete members
};

interface HTMLTableColElement : HTMLElement {
           attribute unsigned long span;

  // also has obsolete members
};

interface HTMLTableSectionElement : HTMLElement {
  readonly attribute HTMLCollection rows;
  HTMLElement insertRow(optional long index = -1);
  void deleteRow(long index);

  // also has obsolete members
};

interface HTMLTableRowElement : HTMLElement {
  readonly attribute long rowIndex;
  readonly attribute long sectionRowIndex;
  readonly attribute HTMLCollection cells;
  HTMLElement insertCell(optional long index = -1);
  void deleteCell(long index);

  // also has obsolete members
};

interface HTMLTableDataCellElement : HTMLTableCellElement {
  // also has obsolete members
};

interface HTMLTableHeaderCellElement : HTMLTableCellElement {
           attribute DOMString scope;
           attribute DOMString abbr;
           attribute DOMString sorted;
  void sort();
};

interface HTMLTableCellElement : HTMLElement {
           attribute unsigned long colSpan;
           attribute unsigned long rowSpan;
  [PutForwards=value] readonly attribute DOMSettableTokenList headers;
  readonly attribute long cellIndex;

  // also has obsolete members
};

[OverrideBuiltins]
interface HTMLFormElement : HTMLElement {
           attribute DOMString acceptCharset;
           attribute DOMString action;
           attribute DOMString autocomplete;
           attribute DOMString enctype;
           attribute DOMString encoding;
           attribute DOMString method;
           attribute DOMString name;
           attribute boolean noValidate;
           attribute DOMString target;

  readonly attribute HTMLFormControlsCollection elements;
  readonly attribute long length;
  getter Element (unsigned long index);
  getter object (DOMString name);

  void submit();
  void reset();
  boolean checkValidity();
};

interface HTMLFieldSetElement : HTMLElement {
           attribute boolean disabled;
  readonly attribute HTMLFormElement? form;
           attribute DOMString name;

  readonly attribute DOMString type;

  readonly attribute HTMLFormControlsCollection elements;

  readonly attribute boolean willValidate;
  readonly attribute ValidityState validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);
};

interface HTMLLegendElement : HTMLElement {
  readonly attribute HTMLFormElement? form;

  // also has obsolete members
};

interface HTMLLabelElement : HTMLElement {
  readonly attribute HTMLFormElement? form;
           attribute DOMString htmlFor;
  readonly attribute HTMLElement? control;
};

interface HTMLInputElement : HTMLElement {
           attribute DOMString accept;
           attribute DOMString alt;
           attribute DOMString autocomplete;
           attribute boolean autofocus;
           attribute boolean defaultChecked;
           attribute boolean checked;
           attribute DOMString dirName;
           attribute boolean disabled;
  readonly attribute HTMLFormElement? form;
  readonly attribute FileList? files;
           attribute DOMString formAction;
           attribute DOMString formEnctype;
           attribute DOMString formMethod;
           attribute boolean formNoValidate;
           attribute DOMString formTarget;
           attribute unsigned long height;
           attribute boolean indeterminate;
           attribute DOMString inputMode;
  readonly attribute HTMLElement? list;
           attribute DOMString max;
           attribute long maxLength;
           attribute DOMString min;
           attribute boolean multiple;
           attribute DOMString name;
           attribute DOMString pattern;
           attribute DOMString placeholder;
           attribute boolean readOnly;
           attribute boolean required;
           attribute unsigned long size;
           attribute DOMString src;
           attribute DOMString step;
           attribute DOMString type;
           attribute DOMString defaultValue;
  [TreatNullAs=EmptyString] attribute DOMString value;
           attribute Date? valueAsDate;
           attribute unrestricted double valueAsNumber;
           attribute unsigned long width;

  void stepUp(optional long n = 1);
  void stepDown(optional long n = 1);

  readonly attribute boolean willValidate;
  readonly attribute ValidityState validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute NodeList labels;

  void select();
           attribute unsigned long selectionStart;
           attribute unsigned long selectionEnd;
           attribute DOMString selectionDirection;
  void setRangeText(DOMString replacement);
  void setRangeText(DOMString replacement, unsigned long start, unsigned long end, optional SelectionMode selectionMode);
  void setSelectionRange(unsigned long start, unsigned long end, optional DOMString direction);

  // also has obsolete members
};

interface HTMLButtonElement : HTMLElement {
           attribute boolean autofocus;
           attribute boolean disabled;
  readonly attribute HTMLFormElement? form;
           attribute DOMString formAction;
           attribute DOMString formEnctype;
           attribute DOMString formMethod;
           attribute boolean formNoValidate;
           attribute DOMString formTarget;
           attribute DOMString name;
           attribute DOMString type;
           attribute DOMString value;
           attribute HTMLMenuElement? menu;

  readonly attribute boolean willValidate;
  readonly attribute ValidityState validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute NodeList labels;
};

interface HTMLSelectElement : HTMLElement {
           attribute boolean autofocus;
           attribute boolean disabled;
  readonly attribute HTMLFormElement? form;
           attribute boolean multiple;
           attribute DOMString name;
           attribute boolean required;
           attribute unsigned long size;

  readonly attribute DOMString type;

  readonly attribute HTMLOptionsCollection options;
           attribute unsigned long length;
  getter Element item(unsigned long index);
  object namedItem(DOMString name);
  void add((HTMLOptionElement or HTMLOptGroupElement) element, optional (HTMLElement or long)? before = null);
  void remove(long index);
  setter creator void (unsigned long index, HTMLOptionElement? option);

  readonly attribute HTMLCollection selectedOptions;
           attribute long selectedIndex;
           attribute DOMString value;

  readonly attribute boolean willValidate;
  readonly attribute ValidityState validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute NodeList labels;
};

interface HTMLDataListElement : HTMLElement {
  readonly attribute HTMLCollection options;
};

interface HTMLOptGroupElement : HTMLElement {
           attribute boolean disabled;
           attribute DOMString label;
};

[NamedConstructor=Option(optional DOMString text = "", optional DOMString value, optional boolean defaultSelected = false, optional boolean selected = false)]
interface HTMLOptionElement : HTMLElement {
           attribute boolean disabled;
  readonly attribute HTMLFormElement? form;
           attribute DOMString label;
           attribute boolean defaultSelected;
           attribute boolean selected;
           attribute DOMString value;

           attribute DOMString text;
  readonly attribute long index;
};

interface HTMLTextAreaElement : HTMLElement {
           attribute DOMString autocomplete;
           attribute boolean autofocus;
           attribute unsigned long cols;
           attribute DOMString dirName;
           attribute boolean disabled;
  readonly attribute HTMLFormElement? form;
           attribute DOMString inputMode;
           attribute long maxLength;
           attribute DOMString name;
           attribute DOMString placeholder;
           attribute boolean readOnly;
           attribute boolean required;
           attribute unsigned long rows;
           attribute DOMString wrap;

  readonly attribute DOMString type;
           attribute DOMString defaultValue;
  [TreatNullAs=EmptyString] attribute DOMString value;
  readonly attribute unsigned long textLength;

  readonly attribute boolean willValidate;
  readonly attribute ValidityState validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute NodeList labels;

  void select();
           attribute unsigned long selectionStart;
           attribute unsigned long selectionEnd;
           attribute DOMString selectionDirection;
  void setRangeText(DOMString replacement);
  void setRangeText(DOMString replacement, unsigned long start, unsigned long end, optional SelectionMode selectionMode);
  void setSelectionRange(unsigned long start, unsigned long end, optional DOMString direction);
};

interface HTMLKeygenElement : HTMLElement {
           attribute boolean autofocus;
           attribute DOMString challenge;
           attribute boolean disabled;
  readonly attribute HTMLFormElement? form;
           attribute DOMString keytype;
           attribute DOMString name;

  readonly attribute DOMString type;

  readonly attribute boolean willValidate;
  readonly attribute ValidityState validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute NodeList labels;
};

interface HTMLOutputElement : HTMLElement {
  [PutForwards=value] readonly attribute DOMSettableTokenList htmlFor;
  readonly attribute HTMLFormElement? form;
           attribute DOMString name;

  readonly attribute DOMString type;
           attribute DOMString defaultValue;
           attribute DOMString value;

  readonly attribute boolean willValidate;
  readonly attribute ValidityState validity;
  readonly attribute DOMString validationMessage;
  boolean checkValidity();
  void setCustomValidity(DOMString error);

  readonly attribute NodeList labels;
};

interface HTMLProgressElement : HTMLElement {
           attribute double value;
           attribute double max;
  readonly attribute double position;
  readonly attribute NodeList labels;
};

interface HTMLMeterElement : HTMLElement {
           attribute double value;
           attribute double min;
           attribute double max;
           attribute double low;
           attribute double high;
           attribute double optimum;
  readonly attribute NodeList labels;
};

enum SelectionMode {
  "select",
  "start",
  "end",
  "preserve"
};

interface ValidityState {
  readonly attribute boolean valueMissing;
  readonly attribute boolean typeMismatch;
  readonly attribute boolean patternMismatch;
  readonly attribute boolean tooLong;
  readonly attribute boolean rangeUnderflow;
  readonly attribute boolean rangeOverflow;
  readonly attribute boolean stepMismatch;
  readonly attribute boolean badInput;
  readonly attribute boolean customError;
  readonly attribute boolean valid;
};

interface HTMLDetailsElement : HTMLElement {
           attribute boolean open;
};

interface HTMLMenuElement : HTMLElement {
           attribute DOMString type;
           attribute DOMString label;

  // also has obsolete members
};

interface HTMLMenuItemElement : HTMLElement {
           attribute DOMString type;
           attribute DOMString label;
           attribute DOMString icon;
           attribute boolean disabled;
           attribute boolean checked;
           attribute DOMString radiogroup;
           attribute boolean default;
  readonly attribute HTMLElement? command;
};

[Constructor(DOMString type, optional RelatedEventInit eventInitDict)]
interface RelatedEvent : Event {
  readonly attribute EventTarget? relatedTarget;
};

dictionary RelatedEventInit : EventInit {
  EventTarget? relatedTarget;
};

interface HTMLDialogElement : HTMLElement {
           attribute boolean open;
           attribute DOMString returnValue;
  void show(optional (MouseEvent or Element) anchor);
  void showModal(optional (MouseEvent or Element) anchor);
  void close(optional DOMString returnValue);
};

[NamedPropertiesObject]
/*sealed*/ interface Window : EventTarget {
  // the current browsing context
  [Unforgeable] readonly attribute WindowProxy window;
  [Replaceable] readonly attribute WindowProxy self;
  [Unforgeable] readonly attribute Document document;
           attribute DOMString name;
  [PutForwards=href, Unforgeable] readonly attribute Location location;
  readonly attribute History history;
  [Replaceable] readonly attribute BarProp locationbar;
  [Replaceable] readonly attribute BarProp menubar;
  [Replaceable] readonly attribute BarProp personalbar;
  [Replaceable] readonly attribute BarProp scrollbars;
  [Replaceable] readonly attribute BarProp statusbar;
  [Replaceable] readonly attribute BarProp toolbar;
           attribute DOMString status;
  void close();
  void stop();
  void focus();
  void blur();

  // other browsing contexts
  [Replaceable] readonly attribute WindowProxy frames;
  [Replaceable] readonly attribute unsigned long length;
  [Unforgeable] readonly attribute WindowProxy top;
           attribute WindowProxy? opener;
  readonly attribute WindowProxy parent;
  readonly attribute Element? frameElement;
  WindowProxy open(optional DOMString url, optional DOMString target, optional DOMString features, optional boolean replace);
  getter WindowProxy (unsigned long index);
  getter object (DOMString name);

  // the user agent
  readonly attribute Navigator navigator;
  readonly attribute External external;
  readonly attribute ApplicationCache applicationCache;

  // user prompts
  // TODO https://www.w3.org/Bugs/Public/show_bug.cgi?id=21587
  // void alert(DOMString message);
  // boolean confirm(DOMString message);
  // DOMString? prompt(DOMString message, optional DOMString default);
  void print();
  // TODO freezes WebKit
  // any showModalDialog(DOMString url, optional any argument);

  void postMessage(any message, DOMString targetOrigin, optional sequence<Transferable> transfer);
};
Window implements GlobalEventHandlers;
Window implements WindowEventHandlers;

interface BarProp {
           attribute boolean visible;
};

interface History {
  readonly attribute long length;
  readonly attribute any state;
  void go(optional long delta);
  void back();
  void forward();
  void pushState(any data, DOMString title, optional DOMString? url = null);
  void replaceState(any data, DOMString title, optional DOMString? url = null);
};

[Unforgeable] interface Location {
  stringifier attribute DOMString href;
  // TODO causes infinite loop in Opera
  // void assign(DOMString url);
  // void replace(DOMString url);
  void reload();
};
Location implements URLUtils;

[Constructor(DOMString type, optional PopStateEventInit eventInitDict)]
interface PopStateEvent : Event {
  readonly attribute any state;
};

dictionary PopStateEventInit : EventInit {
  any state;
};

[Constructor(DOMString type, optional HashChangeEventInit eventInitDict)]
interface HashChangeEvent : Event {
  readonly attribute DOMString oldURL;
  readonly attribute DOMString newURL;
};

dictionary HashChangeEventInit : EventInit {
  DOMString oldURL;
  DOMString newURL;
};

[Constructor(DOMString type, optional PageTransitionEventInit eventInitDict)]
interface PageTransitionEvent : Event {
  readonly attribute boolean persisted;
};

dictionary PageTransitionEventInit : EventInit {
  boolean persisted;
};

interface BeforeUnloadEvent : Event {
           attribute DOMString returnValue;
};

interface ApplicationCache : EventTarget {

  // update status
  const unsigned short UNCACHED = 0;
  const unsigned short IDLE = 1;
  const unsigned short CHECKING = 2;
  const unsigned short DOWNLOADING = 3;
  const unsigned short UPDATEREADY = 4;
  const unsigned short OBSOLETE = 5;
  readonly attribute unsigned short status;

  // updates
  void update();
  void abort();
  void swapCache();

  // events
           attribute EventHandler onchecking;
           attribute EventHandler onerror;
           attribute EventHandler onnoupdate;
           attribute EventHandler ondownloading;
           attribute EventHandler onprogress;
           attribute EventHandler onupdateready;
           attribute EventHandler oncached;
           attribute EventHandler onobsolete;
};

[NoInterfaceObject]
interface NavigatorOnLine {
  readonly attribute boolean onLine;
};

[TreatNonCallableAsNull]
callback EventHandlerNonNull = any (Event event);
typedef EventHandlerNonNull? EventHandler;

[TreatNonCallableAsNull]
callback OnErrorEventHandlerNonNull = any ((Event or DOMString) event, optional DOMString source, optional unsigned long lineno, optional unsigned long column);
typedef OnErrorEventHandlerNonNull? OnErrorEventHandler;

[NoInterfaceObject]
interface GlobalEventHandlers {
           attribute EventHandler onabort;
           attribute EventHandler onblur;
           attribute OnErrorEventHandler onerror;
           attribute EventHandler onfocus;
           attribute EventHandler oncancel;
           attribute EventHandler oncanplay;
           attribute EventHandler oncanplaythrough;
           attribute EventHandler onchange;
           attribute EventHandler onclick;
           attribute EventHandler onclose;
           attribute EventHandler oncontextmenu;
           attribute EventHandler oncuechange;
           attribute EventHandler ondblclick;
           attribute EventHandler ondrag;
           attribute EventHandler ondragend;
           attribute EventHandler ondragenter;
           attribute EventHandler ondragexit;
           attribute EventHandler ondragleave;
           attribute EventHandler ondragover;
           attribute EventHandler ondragstart;
           attribute EventHandler ondrop;
           attribute EventHandler ondurationchange;
           attribute EventHandler onemptied;
           attribute EventHandler onended;
           attribute EventHandler oninput;
           attribute EventHandler oninvalid;
           attribute EventHandler onkeydown;
           attribute EventHandler onkeypress;
           attribute EventHandler onkeyup;
           attribute EventHandler onload;
           attribute EventHandler onloadeddata;
           attribute EventHandler onloadedmetadata;
           attribute EventHandler onloadstart;
           attribute EventHandler onmousedown;
  [LenientThis] attribute EventHandler onmouseenter;
  [LenientThis] attribute EventHandler onmouseleave;
           attribute EventHandler onmousemove;
           attribute EventHandler onmouseout;
           attribute EventHandler onmouseover;
           attribute EventHandler onmouseup;
           attribute EventHandler onmousewheel;
           attribute EventHandler onpause;
           attribute EventHandler onplay;
           attribute EventHandler onplaying;
           attribute EventHandler onprogress;
           attribute EventHandler onratechange;
           attribute EventHandler onreset;
           attribute EventHandler onscroll;
           attribute EventHandler onseeked;
           attribute EventHandler onseeking;
           attribute EventHandler onselect;
           attribute EventHandler onshow;
           attribute EventHandler onsort;
           attribute EventHandler onstalled;
           attribute EventHandler onsubmit;
           attribute EventHandler onsuspend;
           attribute EventHandler ontimeupdate;
           attribute EventHandler onvolumechange;
           attribute EventHandler onwaiting;
};

[NoInterfaceObject]
interface WindowEventHandlers {
           attribute EventHandler onafterprint;
           attribute EventHandler onbeforeprint;
           attribute EventHandler onbeforeunload;
           attribute EventHandler onfullscreenchange;
           attribute EventHandler onfullscreenerror;
           attribute EventHandler onhashchange;
           attribute EventHandler onmessage;
           attribute EventHandler onoffline;
           attribute EventHandler ononline;
           attribute EventHandler onpagehide;
           attribute EventHandler onpageshow;
           attribute EventHandler onpopstate;
           attribute EventHandler onresize;
           attribute EventHandler onstorage;
           attribute EventHandler onunload;
};

[NoInterfaceObject]
interface WindowBase64 {
  DOMString btoa(DOMString btoa);
  DOMString atob(DOMString atob);
};
Window implements WindowBase64;

[NoInterfaceObject]
interface WindowTimers {
  long setTimeout(Function handler, optional long timeout, any... arguments);
  long setTimeout(DOMString handler, optional long timeout, any... arguments);
  void clearTimeout(long handle);
  long setInterval(Function handler, optional long timeout, any... arguments);
  long setInterval(DOMString handler, optional long timeout, any... arguments);
  void clearInterval(long handle);
};
Window implements WindowTimers;

[NoInterfaceObject] interface WindowModal {
  readonly attribute any dialogArguments;
           attribute DOMString returnValue;
};

interface Navigator {
  // objects implementing this interface also implement the interfaces given below
};
Navigator implements NavigatorID;
Navigator implements NavigatorLanguage;
Navigator implements NavigatorOnLine;
Navigator implements NavigatorContentUtils;
Navigator implements NavigatorStorageUtils;

[NoInterfaceObject]
interface NavigatorID {
  readonly attribute DOMString appName;
  readonly attribute DOMString appVersion;
  readonly attribute DOMString platform;
  readonly attribute DOMString userAgent;

  // TODO: Invalid WebIDL
  // const DOMString product = "Gecko"; // for historical reasons
};

[NoInterfaceObject]
interface NavigatorLanguage {
  readonly attribute DOMString? language;
};

[NoInterfaceObject]
interface NavigatorContentUtils {
  // content handler registration
  void registerProtocolHandler(DOMString scheme, DOMString url, DOMString title);
  void registerContentHandler(DOMString mimeType, DOMString url, DOMString title);
  DOMString isProtocolHandlerRegistered(DOMString scheme, DOMString url);
  DOMString isContentHandlerRegistered(DOMString mimeType, DOMString url);
  void unregisterProtocolHandler(DOMString scheme, DOMString url);
  void unregisterContentHandler(DOMString mimeType, DOMString url);
};

[NoInterfaceObject]
interface NavigatorStorageUtils {
  void yieldForStorageUpdates();
};

interface External {
  void AddSearchProvider(DOMString engineURL);
  unsigned long IsSearchProviderInstalled(DOMString engineURL);
};

interface ImageBitmap {
  // opaque object
};

callback ImageBitmapCallback = void (ImageBitmap image);

typedef (HTMLImageElement or
         HTMLVideoElement or
         HTMLCanvasElement or
         Blob or
         ImageData or
         CanvasRenderingContext2D or
         ImageBitmap) ImageBitmapSource;

[NoInterfaceObject]
interface ImageBitmapFactories {
  void createImageBitmap(ImageBitmapSource image, ImageBitmapCallback _callback, optional long sx, long sy, long sw, long sh);
};
Window implements ImageBitmapFactories;
WorkerGlobalScope implements ImageBitmapFactories;

interface DataTransfer {
           attribute DOMString dropEffect;
           attribute DOMString effectAllowed;

  readonly attribute DataTransferItemList items;

  void setDragImage(Element image, long x, long y);

  /* old interface */
  readonly attribute DOMString[] types;
  DOMString getData(DOMString format);
  void setData(DOMString format, DOMString data);
  void clearData(optional DOMString format);
  readonly attribute FileList files;
};

interface DataTransferItemList {
  readonly attribute unsigned long length;
  getter DataTransferItem (unsigned long index);
  deleter void (unsigned long index);
  void clear();

  DataTransferItem? add(DOMString data, DOMString type);
  DataTransferItem? add(File data);
};

interface DataTransferItem {
  readonly attribute DOMString kind;
  readonly attribute DOMString type;
  void getAsString(FunctionStringCallback? _callback);
  File? getAsFile();
};

[Callback, NoInterfaceObject]
interface FunctionStringCallback {
  void handleEvent(DOMString data);
};

[Constructor(DOMString type, optional DragEventInit eventInitDict)]
interface DragEvent : MouseEvent {
  readonly attribute DataTransfer? dataTransfer;
};

dictionary DragEventInit : MouseEventInit {
  DataTransfer? dataTransfer;
};

interface WorkerGlobalScope : EventTarget {
  readonly attribute WorkerGlobalScope self;
  readonly attribute WorkerLocation location;

  void close();
           attribute EventHandler onerror;
           attribute EventHandler onoffline;
           attribute EventHandler ononline;

  // also has obsolete members
};

interface DedicatedWorkerGlobalScope : WorkerGlobalScope {
  void postMessage(any message, optional sequence<Transferable> transfer);
           attribute EventHandler onmessage;
};

interface SharedWorkerGlobalScope : WorkerGlobalScope {
  readonly attribute DOMString name;
  readonly attribute ApplicationCache applicationCache;
           attribute EventHandler onconnect;
};

[Constructor(DOMString type, optional ErrorEventInit eventInitDict)]
interface ErrorEvent : Event {
  readonly attribute DOMString message;
  readonly attribute DOMString filename;
  readonly attribute unsigned long lineno;
  readonly attribute unsigned long column;
};

dictionary ErrorEventInit : EventInit {
  DOMString message;
  DOMString filename;
  unsigned long lineno;
  unsigned long column;
};

[NoInterfaceObject]
interface AbstractWorker {
           attribute EventHandler onerror;

};

[Constructor(DOMString scriptURL)]
interface Worker : EventTarget {
  void terminate();

  void postMessage(any message, optional sequence<Transferable> transfer);
           attribute EventHandler onmessage;
};
Worker implements AbstractWorker;

[Constructor(DOMString scriptURL, optional DOMString name)]
interface SharedWorker : EventTarget {
  readonly attribute MessagePort port;
};
SharedWorker implements AbstractWorker;

[NoInterfaceObject]
partial interface WorkerGlobalScope {
  void importScripts(DOMString... urls);
  readonly attribute WorkerNavigator navigator;
};
WorkerGlobalScope implements WindowTimers;
WorkerGlobalScope implements WindowBase64;

interface WorkerNavigator {};
WorkerNavigator implements NavigatorID;
WorkerNavigator implements NavigatorLanguage;
WorkerNavigator implements NavigatorOnLine;

interface WorkerLocation {
  stringifier readonly attribute DOMString href;
};
WorkerLocation implements URLUtilsReadOnly;

[Constructor(DOMString type, optional MessageEventInit eventInitDict)]
interface MessageEvent : Event {
  readonly attribute any data;
  readonly attribute DOMString origin;
  readonly attribute DOMString lastEventId;
  readonly attribute (WindowProxy or MessagePort)? source;
  readonly attribute MessagePort[]? ports;
};

dictionary MessageEventInit : EventInit {
  any data;
  DOMString origin;
  DOMString lastEventId;
  WindowProxy? source;
  MessagePort[]? ports;
};

[Constructor(DOMString url, optional EventSourceInit eventSourceInitDict)]
interface EventSource : EventTarget {
  readonly attribute DOMString url;
  readonly attribute boolean withCredentials;

  // ready state
  const unsigned short CONNECTING = 0;
  const unsigned short OPEN = 1;
  const unsigned short CLOSED = 2;
  readonly attribute unsigned short readyState;

  // networking
           attribute EventHandler onopen;
           attribute EventHandler onmessage;
           attribute EventHandler onerror;
  void close();
};

dictionary EventSourceInit {
  boolean withCredentials = false;
};

enum BinaryType { "blob", "arraybuffer" };
[Constructor(DOMString url, optional (DOMString or DOMString[]) protocols)]
interface WebSocket : EventTarget {
  readonly attribute DOMString url;

  // ready state
  const unsigned short CONNECTING = 0;
  const unsigned short OPEN = 1;
  const unsigned short CLOSING = 2;
  const unsigned short CLOSED = 3;
  readonly attribute unsigned short readyState;
  readonly attribute unsigned long bufferedAmount;

  // networking
           attribute EventHandler onopen;
           attribute EventHandler onerror;
           attribute EventHandler onclose;
  readonly attribute DOMString extensions;
  readonly attribute DOMString protocol;
  void close([Clamp] optional unsigned short code, optional DOMString reason);

  // messaging
           attribute EventHandler onmessage;
           attribute BinaryType binaryType;
  void send(DOMString data);
  void send(Blob data);
  void send(ArrayBuffer data);
  void send(ArrayBufferView data);
};

[Constructor(DOMString type, optional CloseEventInit eventInitDict)]
interface CloseEvent : Event {
  readonly attribute boolean wasClean;
  readonly attribute unsigned short code;
  readonly attribute DOMString reason;
};

dictionary CloseEventInit : EventInit {
  boolean wasClean;
  unsigned short code;
  DOMString reason;
};

[Constructor]
interface MessageChannel {
  readonly attribute MessagePort port1;
  readonly attribute MessagePort port2;
};

interface MessagePort : EventTarget {
  void postMessage(any message, optional sequence<Transferable> transfer);
  void start();
  void close();

  // event handlers
           attribute EventHandler onmessage;
};
MessagePort implements Transferable;

[Constructor] interface PortCollection {
  void add(MessagePort port);
  void remove(MessagePort port);
  void clear();
  void iterate(PortCollectionCallback callback);
};

callback PortCollectionCallback = void (MessagePort port);

interface Storage {
  readonly attribute unsigned long length;
  DOMString? key(unsigned long index);
  getter DOMString? getItem(DOMString key);
  setter creator void setItem(DOMString key, DOMString value);
  deleter void removeItem(DOMString key);
  void clear();
};

[NoInterfaceObject]
interface WindowSessionStorage {
  readonly attribute Storage sessionStorage;
};
Window implements WindowSessionStorage;

[NoInterfaceObject]
interface WindowLocalStorage {
  readonly attribute Storage localStorage;
};
Window implements WindowLocalStorage;

[Constructor(DOMString type, optional StorageEventInit eventInitDict)]
interface StorageEvent : Event {
  readonly attribute DOMString? key;
  readonly attribute DOMString? oldValue;
  readonly attribute DOMString? newValue;
  readonly attribute DOMString url;
  readonly attribute Storage? storageArea;
};

dictionary StorageEventInit : EventInit {
  DOMString? key;
  DOMString? oldValue;
  DOMString? newValue;
  DOMString url;
  Storage? storageArea;
};

interface HTMLAppletElement : HTMLElement {
           attribute DOMString align;
           attribute DOMString alt;
           attribute DOMString archive;
           attribute DOMString code;
           attribute DOMString codeBase;
           attribute DOMString height;
           attribute unsigned long hspace;
           attribute DOMString name;
           attribute DOMString _object; // the underscore is not part of the identifier
           attribute unsigned long vspace;
           attribute DOMString width;
};

interface HTMLMarqueeElement : HTMLElement {
           attribute DOMString behavior;
           attribute DOMString bgColor;
           attribute DOMString direction;
           attribute DOMString height;
           attribute unsigned long hspace;
           attribute long loop;
           attribute unsigned long scrollAmount;
           attribute unsigned long scrollDelay;
           attribute boolean trueSpeed;
           attribute unsigned long vspace;
           attribute DOMString width;

           attribute EventHandler onbounce;
           attribute EventHandler onfinish;
           attribute EventHandler onstart;

  void start();
  void stop();
};

interface HTMLFrameSetElement : HTMLElement {
           attribute DOMString cols;
           attribute DOMString rows;
};
HTMLFrameSetElement implements WindowEventHandlers;

interface HTMLFrameElement : HTMLElement {
           attribute DOMString name;
           attribute DOMString scrolling;
           attribute DOMString src;
           attribute DOMString frameBorder;
           attribute DOMString longDesc;
           attribute boolean noResize;
  readonly attribute Document? contentDocument;
  readonly attribute WindowProxy? contentWindow;

  [TreatNullAs=EmptyString] attribute DOMString marginHeight;
  [TreatNullAs=EmptyString] attribute DOMString marginWidth;
};

partial interface HTMLAnchorElement {
           attribute DOMString coords;
           attribute DOMString charset;
           attribute DOMString name;
           attribute DOMString rev;
           attribute DOMString shape;
};

partial interface HTMLAreaElement {
           attribute boolean noHref;
};

partial interface HTMLBodyElement {
  [TreatNullAs=EmptyString] attribute DOMString text;
  [TreatNullAs=EmptyString] attribute DOMString link;
  [TreatNullAs=EmptyString] attribute DOMString vLink;
  [TreatNullAs=EmptyString] attribute DOMString aLink;
  [TreatNullAs=EmptyString] attribute DOMString bgColor;
                            attribute DOMString background;
};

partial interface HTMLBRElement {
           attribute DOMString clear;
};

partial interface HTMLTableCaptionElement {
           attribute DOMString align;
};

partial interface HTMLTableColElement {
           attribute DOMString align;
           attribute DOMString ch;
           attribute DOMString chOff;
           attribute DOMString vAlign;
           attribute DOMString width;
};

interface HTMLDirectoryElement : HTMLElement {
           attribute boolean compact;
};

partial interface HTMLDivElement {
           attribute DOMString align;
};

partial interface HTMLDListElement {
           attribute boolean compact;
};

partial interface HTMLEmbedElement {
           attribute DOMString align;
           attribute DOMString name;
};

interface HTMLFontElement : HTMLElement {
  [TreatNullAs=EmptyString] attribute DOMString color;
                            attribute DOMString face;
                            attribute DOMString size;
};

partial interface HTMLHeadingElement {
           attribute DOMString align;
};

partial interface HTMLHRElement {
           attribute DOMString align;
           attribute DOMString color;
           attribute boolean noShade;
           attribute DOMString size;
           attribute DOMString width;
};

partial interface HTMLHtmlElement {
           attribute DOMString version;
};

partial interface HTMLIFrameElement {
           attribute DOMString align;
           attribute DOMString scrolling;
           attribute DOMString frameBorder;
           attribute DOMString longDesc;

  [TreatNullAs=EmptyString] attribute DOMString marginHeight;
  [TreatNullAs=EmptyString] attribute DOMString marginWidth;
};

partial interface HTMLImageElement {
           attribute DOMString name;
           attribute DOMString align;
           attribute unsigned long hspace;
           attribute unsigned long vspace;
           attribute DOMString longDesc;

  [TreatNullAs=EmptyString] attribute DOMString border;
};

partial interface HTMLInputElement {
           attribute DOMString align;
           attribute DOMString useMap;
};

partial interface HTMLLegendElement {
           attribute DOMString align;
};

partial interface HTMLLIElement {
           attribute DOMString type;
};

partial interface HTMLLinkElement {
           attribute DOMString charset;
           attribute DOMString rev;
           attribute DOMString target;
};

partial interface HTMLMenuElement {
           attribute boolean compact;
};

partial interface HTMLMetaElement {
           attribute DOMString scheme;
};

partial interface HTMLObjectElement {
           attribute DOMString align;
           attribute DOMString archive;
           attribute DOMString code;
           attribute boolean declare;
           attribute unsigned long hspace;
           attribute DOMString standby;
           attribute unsigned long vspace;
           attribute DOMString codeBase;
           attribute DOMString codeType;

  [TreatNullAs=EmptyString] attribute DOMString border;
};

partial interface HTMLOListElement {
           attribute boolean compact;
};

partial interface HTMLParagraphElement {
           attribute DOMString align;
};

partial interface HTMLParamElement {
           attribute DOMString type;
           attribute DOMString valueType;
};

partial interface HTMLPreElement {
           attribute long width;
};

partial interface HTMLScriptElement {
           attribute DOMString event;
           attribute DOMString htmlFor;
};

partial interface HTMLTableElement {
           attribute DOMString align;
           attribute DOMString border;
           attribute DOMString frame;
           attribute DOMString rules;
           attribute DOMString summary;
           attribute DOMString width;

  [TreatNullAs=EmptyString] attribute DOMString bgColor;
  [TreatNullAs=EmptyString] attribute DOMString cellPadding;
  [TreatNullAs=EmptyString] attribute DOMString cellSpacing;
};

partial interface HTMLTableSectionElement {
           attribute DOMString align;
           attribute DOMString ch;
           attribute DOMString chOff;
           attribute DOMString vAlign;
};

partial interface HTMLTableCellElement {
           attribute DOMString align;
           attribute DOMString axis;
           attribute DOMString height;
           attribute DOMString width;

           attribute DOMString ch;
           attribute DOMString chOff;
           attribute boolean noWrap;
           attribute DOMString vAlign;

  [TreatNullAs=EmptyString] attribute DOMString bgColor;
};

partial interface HTMLTableDataCellElement {
           attribute DOMString abbr;
};

partial interface HTMLTableRowElement {
           attribute DOMString align;
           attribute DOMString ch;
           attribute DOMString chOff;
           attribute DOMString vAlign;

  [TreatNullAs=EmptyString] attribute DOMString bgColor;
};

partial interface HTMLUListElement {
           attribute boolean compact;
           attribute DOMString type;
};

partial interface Document {
  [TreatNullAs=EmptyString] attribute DOMString fgColor;
  [TreatNullAs=EmptyString] attribute DOMString linkColor;
  [TreatNullAs=EmptyString] attribute DOMString vlinkColor;
  [TreatNullAs=EmptyString] attribute DOMString alinkColor;
  [TreatNullAs=EmptyString] attribute DOMString bgColor;

  readonly attribute HTMLCollection anchors;
  readonly attribute HTMLCollection applets;

  void clear();

  readonly attribute HTMLAllCollection all;
};
</script>
<!-- WebVTT IDLs -->
<script type=text/plain>
enum AutoKeyword { "auto" };
enum DirectionSetting { "" /* horizontal */, "rl", "lr" };
enum AlignSetting { "start", "middle", "end", "left", "right" };
[Constructor(double startTime, double endTime, DOMString text)]
interface VTTCue : TextTrackCue {
           attribute VTTRegion? region;
           attribute DirectionSetting vertical;
           attribute boolean snapToLines;
           attribute (double or AutoKeyword) line;
           attribute AlignSetting lineAlign;
           attribute double position;
           attribute AlignSetting positionAlign;
           attribute double size;
           attribute AlignSetting align;
           attribute DOMString text;
  DocumentFragment getCueAsHTML();
};

enum ScrollSetting { "" /* none */, "up" };
[Constructor]
interface VTTRegion {
           attribute double width;
           attribute long lines;
           attribute double regionAnchorX;
           attribute double regionAnchorY;
           attribute double viewportAnchorX;
           attribute double viewportAnchorY;
           attribute ScrollSetting scroll;
};
</script>
<script>
"use strict";
var idlArray;
var errorVideo; // used to get a MediaError object
var iframe; // used to get a Document object (can't use `document` because some test clears the page)
setup(function() {
	idlArray = new IdlArray();
	[].forEach.call(document.querySelectorAll("script[type=text\\/plain]"), function(node) {
		if (node.className == "untested") {
			idlArray.add_untested_idls(node.textContent);
		} else {
			idlArray.add_idls(node.textContent);
		}
	});
	errorVideo = document.createElement('video');
	errorVideo.src = 'data:,';
	errorVideo.preload = 'auto';
	iframe = document.createElement('iframe');
	iframe.hidden = true;
	document.body.appendChild(iframe);
}, {explicit_done:true});
window.onload = function() {
	idlArray.add_objects({
		HTMLAllCollection: ['document.all'],
		HTMLFormControlsCollection: ['document.createElement("form").elements'],
		RadioNodeList: [],
		HTMLOptionsCollection: ['document.createElement("select").options'],
		HTMLPropertiesCollection: ['document.head.properties'],
		PropertyNodeList: [],
		DOMStringMap: ['document.head.dataset'],
		DOMElementMap: ['document.cssElementMap'],
		Transferable: [],
		Document: ['iframe.contentDocument'],
		XMLDocument: ['document.implementation.createDocument(null, "", null)'],
		HTMLElement: [
			'document.createElement("noscript")',
			'document.createElement("section")',
			'document.createElement("nav")',
			'document.createElement("article")',
			'document.createElement("aside")',
			'document.createElement("hgroup")',
			'document.createElement("header")',
			'document.createElement("footer")',
			'document.createElement("address")',
			'document.createElement("dt")',
			'document.createElement("dd")',
			'document.createElement("figure")',
			'document.createElement("figcaption")',
			'document.createElement("em")',
			'document.createElement("strong")',
			'document.createElement("small")',
			'document.createElement("s")',
			'document.createElement("cite")',
			'document.createElement("dfn")',
			'document.createElement("abbr")',
			'document.createElement("code")',
			'document.createElement("var")',
			'document.createElement("samp")',
			'document.createElement("kbd")',
			'document.createElement("sub")',
			'document.createElement("sup")',
			'document.createElement("i")',
			'document.createElement("b")',
			'document.createElement("u")',
			'document.createElement("mark")',
			'document.createElement("ruby")',
			'document.createElement("rt")',
			'document.createElement("rp")',
			'document.createElement("bdi")',
			'document.createElement("bdo")',
			'document.createElement("wbr")',
			'document.createElement("summary")',
			'document.createElement("acronym")',
		],
		HTMLUnknownElement: [
			'document.createElement("quasit")',
			'document.createElement("bgsound")',
			'document.createElement("isindex")',
			'document.createElement("multicol")',
			'document.createElement("nextid")',
			'document.createElement("rb")',
			'document.createElement("spacer")',
			'document.createElement("basefont")',
			'document.createElement("directory")',
			'document.createElement("mod")',
		],
		HTMLHtmlElement: ['document.createElement("html")'],
		HTMLHeadElement: ['document.createElement("head")'],
		HTMLTitleElement: ['document.createElement("title")'],
		HTMLBaseElement: ['document.createElement("base")'],
		HTMLLinkElement: ['document.createElement("link")'],
		HTMLMetaElement: ['document.createElement("meta")'],
		HTMLStyleElement: ['document.createElement("style")'],
		HTMLScriptElement: ['document.createElement("script")'],
		HTMLBodyElement: ['document.createElement("body")'],
		HTMLHeadingElement: [
			'document.createElement("h1")',
			'document.createElement("h2")',
			'document.createElement("h3")',
			'document.createElement("h4")',
			'document.createElement("h5")',
			'document.createElement("h6")',
		],
		HTMLParagraphElement: ['document.createElement("p")'],
		HTMLHRElement: ['document.createElement("hr")'],
		HTMLPreElement: [
			'document.createElement("pre")',
			'document.createElement("listing")',
			'document.createElement("plaintext")',
			'document.createElement("xmp")',
		],
		HTMLQuoteElement: [
			'document.createElement("blockquote")',
			'document.createElement("q")',
		],
		HTMLOlistElement: ['document.createElement("ol")'],
		HTMLUlistElement: ['document.createElement("ul")'],
		HTMLLIElement: ['document.createElement("li")'],
		HTMLDlistElement: ['document.createElement("dl")'],
		HTMLDivElement: ['document.createElement("div")'],
		HTMLAnchorElement: ['document.createElement("a")'],
		HTMLDataElement: ['document.createElement("data")'],
		HTMLTimeElement: ['document.createElement("time")'],
		HTMLSpanElement: ['document.createElement("span")'],
		HTMLBRElement: ['document.createElement("br")'],
		HTMLModElement: [
			'document.createElement("ins")',
			'document.createElement("del")',
		],
		HTMLImageElement: ['document.createElement("img")', 'new Image()'],
		HTMLIframeElement: ['document.createElement("iframe")'],
		HTMLEmbedElement: ['document.createElement("embed")'],
		HTMLObjectElement: ['document.createElement("object")'],
		HTMLParamElement: ['document.createElement("param")'],
		HTMLVideoElement: ['document.createElement("video")'],
		HTMLAudioElement: ['document.createElement("audio")', 'new Audio()'],
		HTMLSourceElement: ['document.createElement("source")'],
		HTMLTrackElement: ['document.createElement("track")'],
		HTMLMediaElement: [],
		MediaError: ['errorVideo.error'],
		AudioTrackList: [],
		AudioTrack: [],
		VideoTrackList: [],
		VideoTrack: [],
		MediaController: ['new MediaController()'],
		TextTrackList: ['document.createElement("video").textTracks'],
		TextTrack: ['document.createElement("track").track'],
		TextTrackCueList: ['document.createElement("video").addTextTrack("subtitles").cues'],
		TextTrackCue: [],
		TimeRanges: ['document.createElement("video").buffered'],
		TrackEvent: ['new TrackEvent("addtrack"; {track:document.createElement("track").track})'],
		HTMLCanvasElement: ['document.createElement("canvas")'],
		CanvasRenderingContext2D: ['document.createElement("canvas").getContext("2d")'],
		CanvasGradient: [],
		CanvasPattern: [],
		TextMetrics: [],
		ImageData: [],
		HTMLMapElement: ['document.createElement("map")'],
		HTMLAreaElement: ['document.createElement("area")'],
		HTMLTableElement: ['document.createElement("table")'],
		HTMLTableCaptionElement: ['document.createElement("caption")'],
		HTMLTableColElement: [
			'document.createElement("colgroup")',
			'document.createElement("col")',
		],
		HTMLTableSectionElement: [
			'document.createElement("tbody")',
			'document.createElement("thead")',
			'document.createElement("tfoot")',
		],
		HTMLTableRowElement: ['document.createElement("tr")'],
		HTMLTableDataCellElement: ['document.createElement("td")'],
		HTMLTableHeaderCellElement: ['document.createElement("th")'],
		HTMLTableCellElement: [],
		HTMLFormElement: ['document.createElement("form")'],
		HTMLFieldsetElement: ['document.createElement("fieldset")'],
		HTMLLegendElement: ['document.createElement("legend")'],
		HTMLLabelElement: ['document.createElement("label")'],
		HTMLInputElement: ['document.createElement("input")'],
		HTMLButtonElement: ['document.createElement("button")'],
		HTMLSelectElement: ['document.createElement("select")'],
		HTMLDataListElement: ['document.createElement("datalist")'],
		HTMLOptGroupElement: ['document.createElement("optgroup")'],
		HTMLOptionElement: ['document.createElement("option")'],
		HTMLTextAreaElement: ['document.createElement("textarea")'],
		HTMLKeygenElement: ['document.createElement("keygen")'],
		HTMLOutputElement: ['document.createElement("output")'],
		HTMLProgressElement: ['document.createElement("progress")'],
		HTMLMeterElement: ['document.createElement("meter")'],
		ValidityState: ['document.createElement("input").validity'],
		HTMLDetailsElement: ['document.createElement("details")'],
		HTMLCommandElement: ['document.createElement("command")'],
		HTMLMenuElement: ['document.createElement("menu")'],
		Window: ['window'],
		BarProp: [],
		History: ['window.history'],
		Location: ['window.location'],
		PopStateEvent: [],
		HashChangeEvent: [],
		PageTransitionEvent: [],
		BeforeUnloadEvent: [],
		ApplicationCache: ['window.applicationCache'],
		WindowModal: [],
		Navigator: ['window.navigator'],
		External: ['window.external'],
		DataTransfer: [],
		DataTransferItemList: [],
		DataTransferItem: [],
		DragEvent: [],
		NavigatorUserMediaError: [],
		MediaStream: [],
		LocalMediaStream: [],
		MediaStreamTrack: [],
		MediaStreamRecorder: [],
		PeerConnection: [],
		MediaStreamEvent: [],
		ErrorEvent: [],
		AbstractWorker: [],
		Worker: [],
		SharedWorker: [],
		MessageEvent: [],
		EventSource: [],
		WebSocket: [],
		CloseEvent: [],
		MessageChannel: [],
		MessagePort: [],
		Storage: [],
		WindowSessionStorage: ['window.sessionStorage'],
		WindowLocalStorage: ['window.localStorage'],
		StorageEvent: [],
		HTMLAppletElement: ['document.createElement("applet")'],
		HTMLMarqueeElement: ['document.createElement("marquee")'],
		HTMLFrameSetElement: ['document.createElement("frameset")'],
		HTMLFrameElement: ['document.createElement("frame")'],
		HTMLDirectoryElement: ['document.createElement("dir")'],
		HTMLFontElement: ['document.createElement("font")'],
		// WebVTT
		VTTCue: ['new VTTCue(0, 1, "foo")'],
		VTTRegion: ['new VTTRegion()']
	});
	idlArray.prevent_multiple_testing("HTMLElement");
	idlArray.test();
	done();
};
</script>
